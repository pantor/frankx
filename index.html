<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Frankx: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Frankx
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">A High-Level Motion API for Franka</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Frankx Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div align="center"> <object type="image/svg+xml" data="https://raw.githubusercontent.com/pantor/frankx/master/doc/logo.svg?sanitize=true" style="pointer-events: none;" width="340"></object> <h3 align="center">High-Level Motion Library for the Franka Panda Robot </h3>
</div><div align="center"> </div> <p><a href="https://github.com/pantor/frankx/actions"><object type="image/svg+xml" data="https://github.com/pantor/frankx/workflows/CI/badge.svg" style="pointer-events: none;">CI</object> </a></p>
<p><a href="https://github.com/pantor/frankx/actions"><object type="image/svg+xml" data="https://github.com/pantor/frankx/workflows/Publish/badge.svg" style="pointer-events: none;">Publish</object> </a></p>
<p><a href="https://github.com/pantor/frankx/issues"><object type="image/svg+xml" data="https://img.shields.io/github/issues/pantor/frankx.svg" style="pointer-events: none;">Issues</object> </a></p>
<p><a href="https://github.com/pantor/frankx/releases"><object type="image/svg+xml" data="https://img.shields.io/github/v/release/pantor/frankx.svg?include_prereleases&amp;sort=semver" style="pointer-events: none;">Releases</object> </a></p>
<p><a href="https://github.com/pantor/frankx/blob/master/LICENSE"><object type="image/svg+xml" data="https://img.shields.io/badge/license-LGPL-green.svg" style="pointer-events: none;">LGPL</object> </a> </p>
<p>Frankx is a high-level motion library (both C++ and Python) for the Franka Emika Panda robot. It adds a Python wrapper around <a href="https://frankaemika.github.io/docs/libfranka.html">libfranka</a>, while replacing necessary real-time programming with higher-level motion commands. As frankx focuses on making real-time trajectory generation easy, it allows the robot to react to unforeseen events.</p>
<h2>Installation</h2>
<p>To start using frankx with Python, you can use pip via </p><div class="fragment"><div class="line">pip install frankx</div>
</div><!-- fragment --><p>Frankx is based on <a href="https://github.com/frankaemika/libfranka">libfranka</a>, <a href="https://eigen.tuxfamily.org">Eigen</a> for transformation calculations and <a href="https://github.com/pybind/pybind11">pybind11</a> for the Python bindings. Frankx uses the <a href="https://github.com/pantor/ruckig">Ruckig</a> library for Online Trajectory Generation (OTG). As the Franka is quite sensitive to acceleration discontinuities, it requires constrained jerk for all motions. After installing the dependencies (the exact versions can be found below), you can build and install frankx via</p>
<div class="fragment"><div class="line">git clone --recurse-submodules git@github.com:pantor/frankx.git</div>
<div class="line">cd frankx</div>
<div class="line">mkdir -p build</div>
<div class="line">cd build</div>
<div class="line">cmake -DBUILD_TYPE=Release ..</div>
<div class="line">make</div>
<div class="line">make install</div>
</div><!-- fragment --><p>To use frankx, you can also include it as a subproject in your parent CMake via <code>add_subdirectory(frankx)</code> and then <code>target_link_libraries(&lt;target&gt; libfrankx)</code>. If you need only the Python module, you can install frankx via</p>
<div class="fragment"><div class="line">pip install .</div>
</div><!-- fragment --><p>Make sure that the built library can be found from Python by adapting your Python Path.</p>
<h3>Using Docker</h3>
<h4>Building the Image</h4>
<p>To use frankx within Docker we have supplied a <a href="docker/Dockerfile">Dockerfile</a> which you currently need to build yourself:</p>
<div class="fragment"><div class="line">git clone https://github.com/pantor/frankx.git</div>
<div class="line">cd frankx/</div>
<div class="line">docker build -t pantor/frankx -f docker/Dockerfile .</div>
</div><!-- fragment --><p>To use another version of libfranka than default (v.0.7.0) simply add the build arg to the command, e.g.:</p>
<div class="fragment"><div class="line">docker build -t pantor/frankx --build-arg libfranka_version=0.7.1 -f docker/Dockerfile .</div>
</div><!-- fragment --><h4>Running the Containers</h4>
<p>To run the container simply:</p>
<div class="fragment"><div class="line">docker run -it --rm --network=host --privileged pantor/frankx</div>
</div><!-- fragment --><p>The container requires access to the host machines network <em>and</em> elevated user rights to allow the docker user to set RT capabilities of the processes run from within it.</p>
<h2>Tutorial</h2>
<p>Frankx comes with both a C++ and Python API that differ only regarding real-time capability. We will introduce both languages next to each other. In your C++ project, just include <code>include &lt;<a class="el" href="frankx_8hpp.html">frankx/frankx.hpp</a>&gt;</code> and link the library. For Python, just <code>import frankx</code>. As a first example, only four lines of code are needed for simple robotic motions.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="frankx_8hpp.html">frankx/frankx.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacefrankx.html">frankx</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Connect to the robot with the FCI IP address</span></div>
<div class="line"><a class="code" href="classfrankx_1_1_robot.html">Robot</a> robot(<span class="stringliteral">&quot;172.16.0.2&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reduce velocity and acceleration of the robot</span></div>
<div class="line">robot.setDynamicRel(0.05);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Move the end-effector 20cm in positive x-direction</span></div>
<div class="line"><span class="keyword">auto</span> motion = <a class="code" href="structmovex_1_1_linear_relative_motion.html">LinearRelativeMotion</a>(<a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(0.2, 0.0, 0.0));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Finally move the robot</span></div>
<div class="line">robot.move(motion);</div>
</div><!-- fragment --><p>The corresponding program in Python is </p><div class="fragment"><div class="line">from frankx <span class="keyword">import</span> Affine, LinearRelativeMotion, Robot</div>
<div class="line"> </div>
<div class="line">robot = Robot(<span class="stringliteral">&quot;172.16.0.2&quot;</span>)</div>
<div class="line">robot.set_dynamic_rel(0.05)</div>
<div class="line"> </div>
<div class="line">motion = LinearRelativeMotion(<a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(0.2, 0.0, 0.0))</div>
<div class="line">robot.move(motion)</div>
</div><!-- fragment --><p>Furthermore, we will introduce methods for geometric calculations, for moving the robot according to different motion types, how to implement real-time reactions and changing waypoints in real time as well as controlling the gripper.</p>
<h3>Geometry</h3>
<p><code><a class="el" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">frankx::Affine</a></code> is a thin wrapper around <a href="https://eigen.tuxfamily.org/dox/group__TutorialGeometry.html">Eigen::Affine3d</a>. It is used for Cartesian poses, frames and transformation. Frankx simplifies the usage of Euler angles (default ZYX-convention). </p><div class="fragment"><div class="line"><span class="comment">// Initiliaze a transformation with an (x, y, z, a=0.0, b=0.0, c=0.0) translation</span></div>
<div class="line"><a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a> z_translation = <a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(0.0, 0.0, 0.5);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a rotation transformation using the (x, y, z, a, b, c) parameter list</span></div>
<div class="line"><a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a> z_rotation = <a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(0.0, 0.0, 0.0, M_PI / 3, 0.0, 0.0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Make use of the wonderful Eigen library</span></div>
<div class="line"><span class="keyword">auto</span> combined_transformation = z_translation * z_rotation;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the Euler angles (a, b, c) in a vector representation</span></div>
<div class="line">Eigen::Vector3d euler_angles = combined_transformation.angles();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the vector representation (x, y, z, a, b, c) of an affine transformation</span></div>
<div class="line"><a class="code" href="namespacefrankx.html#a3ff5f45e0788c6347b020256df16ae42">frankx::Vector6d</a> pose = combined_transformation.vector();</div>
</div><!-- fragment --><p>In all cases, distances are in [m] and rotations in [rad]. Additionally, there are several helper functions for conversion between Eigen and libfranka's std::array objects. In python, this translates into </p><div class="fragment"><div class="line">z_translation = <a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(0.0, 0.0, 0.5)</div>
<div class="line">z_rotation = <a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(0.0, 0.0, 0.0, math.pi / 3, 0.0, 0.0)</div>
<div class="line">combined_transformation = z_translation * z_rotation</div>
<div class="line"> </div>
<div class="line"><span class="comment"># These two are now numpy arrays</span></div>
<div class="line">euler_angles = combined_transformation.angles()</div>
<div class="line">pose = combined_transformation.vector()</div>
</div><!-- fragment --><p>As the trajectory generation works in the Euler space, please make sure to have continuous Euler angles around your working point. You can adapt this by setting the flange to end-effector transformation via <code>setEE(...)</code>.</p>
<h3>Robot</h3>
<p>We wrapped most of the libfanka API (including the RobotState or ErrorMessage) for Python. Moreover, we added methods to adapt the dynamics of the robot for all motions. The <code>rel</code> name denotes that this a factor of the maximum constraints of the Panda robot. </p><div class="fragment"><div class="line">robot = Robot(<span class="stringliteral">&quot;172.16.0.2&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Recover from errors</span></div>
<div class="line">robot.recover_from_errors()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Set velocity, acceleration and jerk to 5% of the maximum</span></div>
<div class="line">robot.set_dynamic_rel(0.05)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Alternatively, you can define each constraint individually</span></div>
<div class="line">robot.velocity_rel = 0.2</div>
<div class="line">robot.acceleration_rel = 0.1</div>
<div class="line">robot.jerk_rel = 0.01</div>
</div><!-- fragment --><h3>Motion Types</h3>
<p>Frankx defines five different motion types. In python, you can use them as follows: </p><div class="fragment"><div class="line"><span class="comment"># A point-to-point motion in the joint space</span></div>
<div class="line">m1 = JointMotion([-1.81194, 1.17910, 1.75710, -2.1416, -1.14336, 1.63304, -0.43217])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># A linear motion in cartesian space</span></div>
<div class="line">m2 = LinearMotion(<a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(0.2, -0.4, 0.3, math.pi / 2, 0.0, 0.0))</div>
<div class="line">m3 = LinearMotion(<a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(0.2, -0.4, 0.3, math.pi / 2, 0.0, 0.0), elbow=1.7)  <span class="comment"># With target elbow angle</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># A linear motion in cartesian space relative to the initial position</span></div>
<div class="line">m4 = LinearRelativeMotion(<a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(0.0, 0.1, 0.0))</div>
<div class="line"> </div>
<div class="line"><span class="comment"># A more complex motion by defining multiple waypoints</span></div>
<div class="line">m5 = WaypointMotion([</div>
<div class="line">  Waypoint(<a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(0.2, -0.4, 0.2, 0.3, 0.2, 0.1)),</div>
<div class="line">  <span class="comment"># The following waypoint is relative to the prior one</span></div>
<div class="line">  Waypoint(<a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(0.0, 0.1, 0.0), Waypoint.ReferenceType.Relative)</div>
<div class="line">])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Hold the position for [s]</span></div>
<div class="line">m6 = PositionHold(5.0)</div>
</div><!-- fragment --><p>The real robot can be moved by applying a motion to the robot using <code>move</code>: </p><div class="fragment"><div class="line">robot.move(m1)</div>
<div class="line">robot.move(m2)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># To use a given frame relative to the end effector</span></div>
<div class="line">camera_frame = <a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(0.1, 0.0, 0.1)</div>
<div class="line">robot.move(camera_frame, m3)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># To change the dynamics of the motion, use MotionData</span></div>
<div class="line">data = MotionData(0.2)  <span class="comment"># Using a dynamic_rel of 0.2 (eventually multiplied with robot.dynamic_rel)</span></div>
<div class="line">robot.move(m4, data)</div>
</div><!-- fragment --><p>Using MotionData, you can adapt the dynamics (velocity, acceleration and jerk) of a specific motion. </p><div class="fragment"><div class="line">data.velocity_rel = 1.0</div>
<div class="line">data.jerk_rel = 0.2</div>
</div><!-- fragment --><h3>Real-Time Reactions</h3>
<p>By adding reactions to the motion data, the robot can react to unforeseen events. In the Python API, you can define conditions by using a comparison between a robot's value and a given threshold. If the threshold is exceeded, the reaction fires. Following comparisons are currently implemented </p><div class="fragment"><div class="line">reaction_motion = LinearRelativeMotion(<a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(0.0, 0.0, 0.01))  <span class="comment"># Move up for 1cm</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Stop motion if the overall force is greater than 30N</span></div>
<div class="line">d1 = MotionData().with_reaction(Reaction(Measure.ForceXYZNorm() &gt; 30.0))</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Apply reaction motion if the force in negative z-direction is greater than 10N</span></div>
<div class="line">d2 = MotionData().with_reaction(Reaction(Measure.ForceZ() &lt; -10.0), reaction_motion)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Stop motion if its duration is above 30s</span></div>
<div class="line">d3 = MotionData().with_reaction(Reaction(Measure.Time() &gt;= 30.0))</div>
<div class="line"> </div>
<div class="line">robot.move(m2, d2)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Check if the reaction was triggered</span></div>
<div class="line"><span class="keywordflow">if</span> d2.has_fired:</div>
<div class="line">  robot.recover_from_errors()</div>
<div class="line">  print(<span class="stringliteral">&#39;Force exceeded 10N!&#39;</span>)</div>
</div><!-- fragment --><p>Once a reaction has fired, it will be neglected furthermore. In C++ you can additionally use lambdas to define more complex behaviours: </p><div class="fragment"><div class="line"><span class="comment">// Stop motion if force is over 10N</span></div>
<div class="line"><span class="keyword">auto</span> data = MotionData()</div>
<div class="line">  .withReaction({</div>
<div class="line">    Measure::ForceXYZNorm() &gt; 10.0  <span class="comment">// [N]</span></div>
<div class="line">  })</div>
<div class="line">  .withReaction({</div>
<div class="line">    [](<span class="keyword">const</span> franka::RobotState&amp; state, <span class="keywordtype">double</span> time) {</div>
<div class="line">      <span class="keywordflow">return</span> (state.current_errors.self_collision_avoidance_violation);</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Hold position for 5s</span></div>
<div class="line">robot.move(PositionHold(5.0), data); <span class="comment">// [s]</span></div>
<div class="line"><span class="comment">// e.g. combined with a PositionHold, the robot continues its program after pushing the end effector.</span></div>
</div><!-- fragment --><h3>Real-Time Waypoint Motion</h3>
<p>While the robot moves in a background thread, you can change the waypoints in real-time. </p><div class="fragment"><div class="line">robot.moveAsync(motion_hold);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wait for key input from user</span></div>
<div class="line">std::cin.get();</div>
<div class="line"> </div>
<div class="line">motion_hold.setNextWaypoint(Waypoint(<a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(0.0, 0.0, 0.1), Waypoint::ReferenceType::Relative);</div>
</div><!-- fragment --><h3>Gripper</h3>
<p>In the <code><a class="el" href="classfrankx_1_1_gripper.html">frankx::Gripper</a></code> class, the default gripper force and gripper speed can be set. Then, additionally to the libfranka commands, the following helper methods can be used:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> gripper = Gripper(<span class="stringliteral">&quot;172.16.0.2&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// These are the default values</span></div>
<div class="line">gripper.gripper_speed = 0.02; <span class="comment">// [m/s]</span></div>
<div class="line">gripper.gripper_force = 20.0; <span class="comment">// [N]</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Preshape gripper before grasp, use the given speed</span></div>
<div class="line">gripper.move(50.0); <span class="comment">// [mm]</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Grasp an object of unknown width</span></div>
<div class="line">is_grasping = gripper.clamp();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Do something</span></div>
<div class="line">is_grasping &amp;= gripper.isGrasping();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Release an object and move to a given distance</span></div>
<div class="line"><span class="keywordflow">if</span> (is_grasping) {</div>
<div class="line">  gripper.release(50.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The Python API should be very straight-forward for the Gripper class.</p>
<h3>Kinematics</h3>
<p>Frankx includes a rudimentary, non-realtime-capable forward and inverse kinematics.</p>
<div class="fragment"><div class="line"><span class="comment"># Some initial joint configuration</span></div>
<div class="line">q = [-1.45549, 1.15401, 1.50061, -2.30909, -1.3141, 1.9391, 0.02815]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Calculate the forward kinematics</span></div>
<div class="line">x = <a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(Kinematics.forward(q))</div>
<div class="line">print(<span class="stringliteral">&#39;Current end effector position: &#39;</span>, x)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define new target position</span></div>
<div class="line">x_new = <a class="code" href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">Affine</a>(x=0.1, y=0.0, z=0.0) * x</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Franka has 7 DoFs, so what to do with the remaining Null space?</span></div>
<div class="line">null_space = NullSpaceHandling(2, 1.4) <span class="comment"># Set elbow joint to 1.4</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Inverse kinematic with target, initial joint angles, and Null space configuration</span></div>
<div class="line">q_new = Kinematics.inverse(x_new.vector(), q, null_space)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&#39;New position: &#39;</span>, x_new)</div>
<div class="line">print(<span class="stringliteral">&#39;New joints: &#39;</span>, q_new)</div>
</div><!-- fragment --><h2>Movex</h2>
<p>We seperated some essential algorithms for robot motions into the standalone C++ library <em>movex</em>.</p>
<h3>Online Trajectory Generators</h3>
<p>All frankx motions are based on Online Trajectory Generators (OTGs) with 7 DoFs for joint motions, 6/7 DoFs for cartesian motions (with optional elbow) or 1 DoF for path motions. Movex implements or wraps several different OTG algorithms:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name </th><th class="markdownTableHeadNone">Input </th><th class="markdownTableHeadNone">Details  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Ruckig</b> </td><td class="markdownTableBodyNone">Current Position, Velocity, Acceleration<br  />
Target Position, Velocity, Acceleration<br  />
Max Velocity, Acceleration, Jerk </td><td class="markdownTableBodyNone">Time-optimal with given constraints.<br  />
Default OTG of Frankx.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Smoothie </td><td class="markdownTableBodyNone">Current Position<br  />
Target Position<br  />
Dynamic Scaling </td><td class="markdownTableBodyNone">Used by Franka in <a href="https://github.com/frankaemika/libfranka/blob/master/examples/examples_common.h">examples</a>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="http://reflexxes.ws/">Reflexxes</a><br  />
 Type II </td><td class="markdownTableBodyNone">Current Position, Velocity<br  />
Target Position, Velocity<br  />
Max Velocity, Acceleration </td><td class="markdownTableBodyNone">Non-constrained Jerk.<br  />
Time-optimal with given constraints.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="http://reflexxes.ws/">Reflexxes</a><br  />
 Type IV </td><td class="markdownTableBodyNone">Current Position, Velocity, Acceleration<br  />
Target Position, Velocity<br  />
Max Velocity, Acceleration, Jerk </td><td class="markdownTableBodyNone">Closed-source and costly for non-academic licenses.<br  />
Time-optimal with given constraints.  </td></tr>
</table>
<p><b>Ruckig</b> is our own jerk-limited, time-optimal, real-time and open-source OTG. For every time step (e.g. the control cycle of the robot), Ruckig outputs the fastest trajectory within the dynamic constraints reaching a target position, from <em>any</em> current position, velocity and acceleration. For a single DoF, you can even specify a target velocity. We think that this could also be very useful outside of frankx.</p>
<h2>Path</h2>
<p>The path library is able to define paths from waypoints and blend them for a smooth second derivative. We are working on a third-order time-parametrization algorithm.</p>
<h2>Documentation</h2>
<p>An auto-generated documentation can be found at <a href="https://pantor.github.io/frankx/">https://pantor.github.io/frankx/</a>. Moreover, there are multiple examples for both C++ and Python in the <a href="https://github.com/pantor/frankx/tree/master/examples">examples</a> directory. We will add a more detailed documentation once frankx reaches v1.0.</p>
<h2>Development</h2>
<p>Frankx is written in C++17 and Python3.7. It is currently tested against following versions</p>
<ul>
<li>Eigen v3.3.7</li>
<li>Libfranka v0.7.1</li>
<li>Pybind11 v2.6</li>
<li>Catch2 v2.9 (only for testing)</li>
</ul>
<h2>License</h2>
<p>For non-commercial applications, this software is licensed under the LGPL v3.0. If you want to use frankx within commercial applications or under a different license, please contact us for individual agreements. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="anamespacefrankx_html"><div class="ttname"><a href="namespacefrankx.html">frankx</a></div><div class="ttdef"><b>Definition:</b> __init__.py:1</div></div>
<div class="ttc" id="astructmovex_1_1_linear_relative_motion_html"><div class="ttname"><a href="structmovex_1_1_linear_relative_motion.html">movex::LinearRelativeMotion</a></div><div class="ttdef"><b>Definition:</b> motion_waypoint.hpp:51</div></div>
<div class="ttc" id="aclassfrankx_1_1_robot_html"><div class="ttname"><a href="classfrankx_1_1_robot.html">frankx::Robot</a></div><div class="ttdef"><b>Definition:</b> robot.hpp:31</div></div>
<div class="ttc" id="anamespacefrankx_html_a3ff5f45e0788c6347b020256df16ae42"><div class="ttname"><a href="namespacefrankx.html#a3ff5f45e0788c6347b020256df16ae42">frankx::Vector6d</a></div><div class="ttdeci">Eigen::Matrix&lt; double, 6, 1 &gt; Vector6d</div><div class="ttdef"><b>Definition:</b> motion_generator.hpp:16</div></div>
<div class="ttc" id="anamespacefrankx_html_a369e24cda80ac20b1945fb2625035fb3"><div class="ttname"><a href="namespacefrankx.html#a369e24cda80ac20b1945fb2625035fb3">frankx::Affine</a></div><div class="ttdeci">affx::Affine Affine</div><div class="ttdef"><b>Definition:</b> motion_generator.hpp:15</div></div>
<div class="ttc" id="afrankx_8hpp_html"><div class="ttname"><a href="frankx_8hpp.html">frankx.hpp</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
